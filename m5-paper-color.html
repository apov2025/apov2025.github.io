<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M5 Paper Color - apov: a point of view</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700&family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --cream: #FBF7F0;
            --warm-white: #FEFCF8;
            --charcoal: #2C2C2C;
            --warm-grey: #8B8680;
            --accent-gold: #D4A574;
            --deep-brown: #4A3728;
            --soft-shadow: rgba(44, 44, 44, 0.08);
            --border-light: rgba(139, 134, 128, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--cream);
            color: var(--charcoal);
            line-height: 1.6;
            font-weight: 300;
            overflow-x: hidden;
        }

        .grain-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            background-image: 
                radial-gradient(circle at 20% 80%, transparent 50%, rgba(44, 44, 44, 0.1) 100%),
                radial-gradient(circle at 80% 20%, transparent 50%, rgba(44, 44, 44, 0.1) 100%),
                radial-gradient(circle at 40% 40%, transparent 50%, rgba(44, 44, 44, 0.05) 100%);
            pointer-events: none;
            z-index: -1;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 60px 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 60px;
        }

        .back-link {
            display: inline-block;
            color: var(--warm-grey);
            text-decoration: none;
            font-size: 1rem;
            margin-bottom: 40px;
            transition: color 0.3s ease;
        }

        .back-link:hover {
            color: var(--accent-gold);
        }

        .main-title {
            font-family: 'Playfair Display', serif;
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 400;
            letter-spacing: -0.02em;
            line-height: 0.9;
            margin-bottom: 20px;
        }

        .title-accent {
            color: var(--accent-gold);
            font-style: italic;
            font-weight: 500;
        }

        .viewer-container {
            background: var(--warm-white);
            border-radius: 24px;
            padding: 40px;
            box-shadow: 
                0 20px 60px var(--soft-shadow),
                0 8px 16px rgba(44, 44, 44, 0.04),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            border: 1px solid var(--border-light);
            position: relative;
            margin-bottom: 40px;
        }

        .viewer-container::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border-radius: 24px;
            padding: 1px;
            background: linear-gradient(135deg, var(--accent-gold), transparent, var(--accent-gold));
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            opacity: 0.3;
        }

        .model-viewer {
            width: 100%;
            height: 600px;
            border-radius: 16px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            position: relative;
            overflow: hidden;
        }

        .loading-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--warm-grey);
            font-size: 1.1rem;
            text-align: center;
        }

        .controls-info {
            margin-top: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            font-size: 0.9rem;
            color: var(--warm-grey);
            text-align: center;
        }

        .description {
            background: var(--warm-white);
            border-radius: 24px;
            padding: 40px;
            box-shadow: 
                0 20px 60px var(--soft-shadow),
                0 8px 16px rgba(44, 44, 44, 0.04),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            border: 1px solid var(--border-light);
            position: relative;
        }

        .description::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border-radius: 24px;
            padding: 1px;
            background: linear-gradient(135deg, var(--accent-gold), transparent, var(--accent-gold));
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            opacity: 0.3;
        }

        .description h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--charcoal);
        }

        .description p {
            margin-bottom: 15px;
            font-weight: 400;
        }

        @media (max-width: 768px) {
            .container {
                padding: 40px 15px;
            }
            
            .viewer-container,
            .description {
                padding: 30px 20px;
                border-radius: 20px;
            }
            
            .model-viewer {
                height: 400px;
            }
        }
    </style>
    <link rel="stylesheet" href="css/common.css">
</head>
<body>
    <div class="grain-overlay"></div>
    
    <div class="container">
        <div class="header">
            <a href="index.html" class="back-link">‚Üê ËøîÂõûÈ¶ñÈ°µ</a>
            <h1 class="main-title">
                <span>M5 Paper Color</span>
            </h1>
        </div>

        <div class="viewer-container">
            <div id="model-viewer" class="model-viewer">
                <div class="loading-message">Ê≠£Âú®Âä†ËΩΩ 3D Ê®°Âûã...</div>
            </div>
            <div class="controls-info">
                üñ±Ô∏è ÊãñÊãΩÊóãËΩ¨ | üîç ÊªöËΩÆÁº©Êîæ | ÂèåÂáªÈáçÁΩÆËßÜËßí
            </div>
        </div>

    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, model;
        
        function identifyScreenArea(geometry, boundingBox) {
            const positions = geometry.attributes.position.array;
            const normals = geometry.attributes.normal.array;
            
            // Analyze all faces and group by normal direction and position
            const faceGroups = {
                front: [], back: [], left: [], right: [], top: [], bottom: []
            };
            
            // Track face areas and positions to find the screen
            const faceAnalysis = [];
            
            for (let i = 0; i < positions.length; i += 9) {
                const v1 = { x: positions[i], y: positions[i + 1], z: positions[i + 2] };
                const v2 = { x: positions[i + 3], y: positions[i + 4], z: positions[i + 5] };
                const v3 = { x: positions[i + 6], y: positions[i + 7], z: positions[i + 8] };
                
                const normal = {
                    x: normals[i + 2],
                    y: normals[i + 5], 
                    z: normals[i + 8]
                };
                
                // Calculate face center and area
                const center = {
                    x: (v1.x + v2.x + v3.x) / 3,
                    y: (v1.y + v2.y + v3.y) / 3,
                    z: (v1.z + v2.z + v3.z) / 3
                };
                
                // Calculate triangle area
                const edge1 = { x: v2.x - v1.x, y: v2.y - v1.y, z: v2.z - v1.z };
                const edge2 = { x: v3.x - v1.x, y: v3.y - v1.y, z: v3.z - v1.z };
                const cross = {
                    x: edge1.y * edge2.z - edge1.z * edge2.y,
                    y: edge1.z * edge2.x - edge1.x * edge2.z,
                    z: edge1.x * edge2.y - edge1.y * edge2.x
                };
                const area = Math.sqrt(cross.x * cross.x + cross.y * cross.y + cross.z * cross.z) / 2;
                
                faceAnalysis.push({
                    vertices: [v1, v2, v3],
                    normal: normal,
                    center: center,
                    area: area,
                    index: i
                });
                
                // Categorize face by dominant normal direction
                const absNormal = { x: Math.abs(normal.x), y: Math.abs(normal.y), z: Math.abs(normal.z) };
                if (absNormal.z > 0.8) {
                    if (normal.z > 0) faceGroups.front.push(faceAnalysis[faceAnalysis.length - 1]);
                    else faceGroups.back.push(faceAnalysis[faceAnalysis.length - 1]);
                } else if (absNormal.x > 0.8) {
                    if (normal.x > 0) faceGroups.right.push(faceAnalysis[faceAnalysis.length - 1]);
                    else faceGroups.left.push(faceAnalysis[faceAnalysis.length - 1]);
                } else if (absNormal.y > 0.8) {
                    if (normal.y > 0) faceGroups.top.push(faceAnalysis[faceAnalysis.length - 1]);
                    else faceGroups.bottom.push(faceAnalysis[faceAnalysis.length - 1]);
                }
            }
            
            // Log analysis results
            console.log('Face analysis:');
            console.log('Front faces:', faceGroups.front.length);
            console.log('Back faces:', faceGroups.back.length);
            console.log('Left faces:', faceGroups.left.length);
            console.log('Right faces:', faceGroups.right.length);
            console.log('Top faces:', faceGroups.top.length);
            console.log('Bottom faces:', faceGroups.bottom.length);
            
            // Find the side with a large, slightly recessed flat area (the screen)
            // The screen is likely on front or back, and should be a cluster of faces
            let screenCandidates = [];
            
            // Check front and back faces for screen-like areas
            [faceGroups.front, faceGroups.back].forEach((group, groupIndex) => {
                if (group.length > 10) { // Screen should have multiple faces
                    console.log(`Analyzing ${groupIndex === 0 ? 'front' : 'back'} group with ${group.length} faces`);
                    
                    // Look for faces that are clustered together (screen area)
                    const clustered = group.filter(face => {
                        // Check if this face is part of a recessed area
                        const avgZ = group.reduce((sum, f) => sum + f.center.z, 0) / group.length;
                        return Math.abs(face.center.z - avgZ) < 0.1; // Faces at similar depth
                    });
                    
                    if (clustered.length > screenCandidates.length) {
                        screenCandidates = clustered;
                        console.log(`Found ${clustered.length} clustered faces for potential screen`);
                    }
                }
            });
            
            if (screenCandidates.length > 0) {
                console.log(`Creating screen geometry from ${screenCandidates.length} faces`);
                
                const screenGeometry = new THREE.BufferGeometry();
                const screenPositions = [];
                const screenNormals = [];
                
                screenCandidates.forEach(face => {
                    face.vertices.forEach(vertex => {
                        screenPositions.push(vertex.x, vertex.y, vertex.z);
                        screenNormals.push(face.normal.x, face.normal.y, face.normal.z);
                    });
                });
                
                screenGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(screenPositions), 3));
                screenGeometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(screenNormals), 3));
                
                return screenGeometry;
            }
            
            console.log('Could not identify screen area');
            return null;
        }
        
        function createFallbackModel() {
            // Create a simple cube as fallback if STL doesn't load
            const geometry = new THREE.BoxGeometry(2, 1, 0.3);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc,  // Light gray color to match STL model
                roughness: 0.4,
                metalness: 0.0
            });
            const cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.receiveShadow = true;
            return cube;
        }
        
        function init() {
            const container = document.getElementById('model-viewer');
            const loadingMessage = container.querySelector('.loading-message');
            
            try {
                // Create scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf8f9fa);
                
                // Create camera
                camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.set(5, 5, 5);
                
                // Create renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Add renderer to container
                container.appendChild(renderer.domElement);
                
                // Add bright ambient light for better visibility
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambientLight);
                
                // Main directional light from front
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
                directionalLight.position.set(0, 5, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene.add(directionalLight);
                
                // Add side lights for even illumination
                const leftLight = new THREE.DirectionalLight(0xffffff, 0.3);
                leftLight.position.set(-10, 0, 0);
                scene.add(leftLight);
                
                const rightLight = new THREE.DirectionalLight(0xffffff, 0.3);
                rightLight.position.set(10, 0, 0);
                scene.add(rightLight);
                
                // Add grid for reference
                const gridHelper = new THREE.GridHelper(10, 10, 0xcccccc, 0xdddddd);
                gridHelper.position.y = -2;
                scene.add(gridHelper);
                
                // Add controls
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.enableZoom = true;
                controls.enablePan = false;
                controls.minDistance = 2;
                controls.maxDistance = 20;
                
                // Try to load STL model, fallback to cube if fails
                const loader = new STLLoader();
                
                // First try with the current filename
                loader.load(
                    'papercolor-00-01.stl',
                    function(geometry) {
                        loadSTLModel(geometry, loadingMessage);
                    },
                    function(progress) {
                        if (progress.lengthComputable) {
                            const percentComplete = (progress.loaded / progress.total * 100);
                            loadingMessage.textContent = `Ê≠£Âú®Âä†ËΩΩ 3D Ê®°Âûã... ${Math.round(percentComplete)}%`;
                        }
                    },
                    function(error) {
                        console.log('First STL load attempt failed, trying fallback cube...');
                        loadFallbackModel(loadingMessage);
                    }
                );
                
                // Add double-click to reset view
                renderer.domElement.addEventListener('dblclick', function() {
                    controls.reset();
                    camera.position.set(5, 5, 5);
                    if (model) {
                        camera.lookAt(model.position);
                    }
                });
                
                // Handle window resize
                window.addEventListener('resize', onWindowResize);
                
                animate();
                
            } catch (error) {
                console.error('Error initializing 3D viewer:', error);
                loadingMessage.textContent = '3D Êü•ÁúãÂô®ÂàùÂßãÂåñÂ§±Ë¥•';
            }
        }
        
        function loadSTLModel(geometry, loadingMessage) {
            try {
                // Log geometry info for debugging
                console.log('Geometry vertices:', geometry.attributes.position.count);
                console.log('Geometry has normals:', !!geometry.attributes.normal);
                
                // Analyze geometry to find potential screen area
                const positions = geometry.attributes.position.array;
                const vertices = [];
                
                // Extract all vertices for analysis
                for (let i = 0; i < positions.length; i += 3) {
                    vertices.push({
                        x: positions[i],
                        y: positions[i + 1],
                        z: positions[i + 2]
                    });
                }
                
                // Find vertices that might be on the screen (largest flat surface)
                console.log('Total vertices:', vertices.length);
                console.log('Sample vertices:', vertices.slice(0, 10));
                
                // Calculate bounding box to understand orientation
                geometry.computeBoundingBox();
                const box = geometry.boundingBox;
                console.log('Bounding box:', {
                    min: { x: box.min.x, y: box.min.y, z: box.min.z },
                    max: { x: box.max.x, y: box.max.y, z: box.max.z }
                });
                
                // Ensure the geometry has normals for proper lighting
                if (!geometry.attributes.normal) {
                    geometry.computeVertexNormals();
                }
                
                // Try to identify screen area by analyzing vertex positions
                const screenGeometry = identifyScreenArea(geometry, box);
                
                if (screenGeometry) {
                    // Create device body (original geometry minus screen)
                    const bodyMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x404040,  // Dark gray for device body
                        roughness: 0.6,
                        metalness: 0.0,
                        side: THREE.DoubleSide,
                        flatShading: false
                    });
                    
                    // Create screen material (light gray for e-ink screen)
                    const screenMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xd0d0d0,  // Light gray for e-ink screen
                        roughness: 0.3,   // Slightly more reflective like a screen
                        metalness: 0.0,
                        side: THREE.DoubleSide,
                        flatShading: false
                    });
                    
                    // Create meshes
                    const bodyMesh = new THREE.Mesh(geometry, bodyMaterial);
                    const screenMesh = new THREE.Mesh(screenGeometry, screenMaterial);
                    
                    // Create a group to hold both parts
                    model = new THREE.Group();
                    model.add(bodyMesh);
                    model.add(screenMesh);
                    
                    bodyMesh.castShadow = true;
                    bodyMesh.receiveShadow = true;
                    screenMesh.castShadow = true;
                    screenMesh.receiveShadow = true;
                    
                    console.log('Created separate screen and body materials');
                } else {
                    // Fallback: single material for whole device
                    const material = new THREE.MeshStandardMaterial({ 
                        color: 0x404040,  // Dark gray for e-ink device
                        roughness: 0.4,
                        metalness: 0.0,
                        side: THREE.DoubleSide,
                        flatShading: false
                    });
                    
                    model = new THREE.Mesh(geometry, material);
                    model.castShadow = true;
                    model.receiveShadow = true;
                    
                    console.log('Using single material for whole device');
                }
                
                // Get model dimensions for proper centering
                const size = new THREE.Vector3();
                box.getSize(size);
                
                // Scale the model to fit nicely in view
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 3 / maxDim;
                model.scale.setScalar(scale);
                
                // Center the device itself at (0, 0, 0)
                // Calculate the center point of the bounding box
                const center = new THREE.Vector3();
                box.getCenter(center);
                
                // Position the model so its center is at world origin (0, 0, 0)
                model.position.x = -center.x * scale;
                model.position.y = -center.y * scale;
                model.position.z = -center.z * scale;
                
                // Rotate model to show screen front-facing
                // Assuming the screen should face the camera initially
                model.rotation.x = 0;  // No tilt
                model.rotation.y = 0;  // Face forward
                model.rotation.z = 0;  // No roll
                
                // If the model is oriented incorrectly, try these rotations:
                // model.rotation.x = -Math.PI / 2;  // Rotate 90 degrees around X-axis
                // model.rotation.y = Math.PI;       // Rotate 180 degrees around Y-axis
                
                scene.add(model);
                
                // Log final model info
                console.log('Model bounding box size:', size);
                console.log('Model scale applied:', scale);
                console.log('Model final position:', model.position);
                console.log('Model rotation:', model.rotation);
                
                // Hide loading message
                loadingMessage.textContent = 'E-ink ËÆæÂ§áÊ®°ÂûãÂä†ËΩΩÊàêÂäüÔºÅÊãñÊãΩÊóãËΩ¨ÔºåÊªöËΩÆÁº©Êîæ';
                setTimeout(() => {
                    loadingMessage.style.display = 'none';
                }, 2000);
                
                // Position camera to view the screen front-on initially
                camera.position.set(0, 2, 5);  // Straight in front, slightly above
                camera.lookAt(0, 0, 0);  // Look at center of grid
                controls.target.set(0, 0, 0);  // Set orbit center to grid center
                controls.update();
                
            } catch (error) {
                console.error('Error processing STL geometry:', error);
                loadFallbackModel(loadingMessage);
            }
        }
        
        function loadFallbackModel(loadingMessage) {
            // Create a simple device-like shape as fallback
            model = createFallbackModel();
            scene.add(model);
            
            loadingMessage.textContent = 'ÊòæÁ§∫È¢ÑËßàÊ®°Âûã - ÊãñÊãΩÊóãËΩ¨ÔºåÊªöËΩÆÁº©Êîæ';
            setTimeout(() => {
                loadingMessage.style.display = 'none';
            }, 2000);
            
            console.log('Fallback model loaded');
        }
        
        function onWindowResize() {
            if (!camera || !renderer) return;
            const container = document.getElementById('model-viewer');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        function animate() {
            if (!renderer || !scene || !camera) return;
            requestAnimationFrame(animate);
            if (controls) controls.update();
            renderer.render(scene, camera);
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>