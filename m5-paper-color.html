<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M5 Paper Color - apov: a point of view</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700&family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --cream: #FBF7F0;
            --warm-white: #FEFCF8;
            --charcoal: #2C2C2C;
            --warm-grey: #8B8680;
            --accent-gold: #D4A574;
            --deep-brown: #4A3728;
            --soft-shadow: rgba(44, 44, 44, 0.08);
            --border-light: rgba(139, 134, 128, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--cream);
            color: var(--charcoal);
            line-height: 1.6;
            font-weight: 300;
            overflow-x: hidden;
        }

        .grain-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            background-image: 
                radial-gradient(circle at 20% 80%, transparent 50%, rgba(44, 44, 44, 0.1) 100%),
                radial-gradient(circle at 80% 20%, transparent 50%, rgba(44, 44, 44, 0.1) 100%),
                radial-gradient(circle at 40% 40%, transparent 50%, rgba(44, 44, 44, 0.05) 100%);
            pointer-events: none;
            z-index: -1;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 60px 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 60px;
        }

        .back-link {
            display: inline-block;
            color: var(--warm-grey);
            text-decoration: none;
            font-size: 1rem;
            margin-bottom: 40px;
            transition: color 0.3s ease;
        }

        .back-link:hover {
            color: var(--accent-gold);
        }

        .main-title {
            font-family: 'Playfair Display', serif;
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 400;
            letter-spacing: -0.02em;
            line-height: 0.9;
            margin-bottom: 20px;
        }

        .title-accent {
            color: var(--accent-gold);
            font-style: italic;
            font-weight: 500;
        }

        .viewer-container {
            background: var(--warm-white);
            border-radius: 24px;
            padding: 40px;
            box-shadow: 
                0 20px 60px var(--soft-shadow),
                0 8px 16px rgba(44, 44, 44, 0.04),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            border: 1px solid var(--border-light);
            position: relative;
            margin-bottom: 40px;
        }

        .viewer-container::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border-radius: 24px;
            padding: 1px;
            background: linear-gradient(135deg, var(--accent-gold), transparent, var(--accent-gold));
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            opacity: 0.3;
        }

        .model-viewer {
            width: 100%;
            height: 600px;
            border-radius: 16px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            position: relative;
            overflow: hidden;
        }

        .loading-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--warm-grey);
            font-size: 1.1rem;
            text-align: center;
        }

        .controls-info {
            margin-top: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            font-size: 0.9rem;
            color: var(--warm-grey);
            text-align: center;
        }

        .description {
            background: var(--warm-white);
            border-radius: 24px;
            padding: 40px;
            box-shadow: 
                0 20px 60px var(--soft-shadow),
                0 8px 16px rgba(44, 44, 44, 0.04),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            border: 1px solid var(--border-light);
            position: relative;
        }

        .description::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border-radius: 24px;
            padding: 1px;
            background: linear-gradient(135deg, var(--accent-gold), transparent, var(--accent-gold));
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            opacity: 0.3;
        }

        .description h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--charcoal);
        }

        .description p {
            margin-bottom: 15px;
            font-weight: 400;
        }

        @media (max-width: 768px) {
            .container {
                padding: 40px 15px;
            }
            
            .viewer-container,
            .description {
                padding: 30px 20px;
                border-radius: 20px;
            }
            
            .model-viewer {
                height: 400px;
            }
        }
    </style>
    <link rel="stylesheet" href="css/common.css">
</head>
<body>
    <div class="grain-overlay"></div>
    
    <div class="container">
        <div class="header">
            <a href="index.html" class="back-link">â† è¿”å›é¦–é¡µ</a>
            <h1 class="main-title">
                <span>M5 Paper Color</span>
            </h1>
        </div>

        <div class="viewer-container">
            <div id="model-viewer" class="model-viewer">
                <div class="loading-message">æ­£åœ¨åŠ è½½ 3D æ¨¡å‹...</div>
            </div>
            <div class="controls-info">
                ğŸ–±ï¸ æ‹–æ‹½æ—‹è½¬ | ğŸ” æ»šè½®ç¼©æ”¾ | åŒå‡»é‡ç½®è§†è§’
            </div>
        </div>

        <div class="description">
            <p>M5 Paper Color æ˜¯ä¸€æ¬¾é©æ–°æ€§çš„å½©è‰²å¢¨æ°´å±è®¾å¤‡ï¼Œç»“åˆäº†ä¼ ç»Ÿå¢¨æ°´å±çš„æŠ¤çœ¼ç‰¹æ€§å’Œå½©è‰²æ˜¾ç¤ºçš„ä¸°å¯Œè¡¨ç°åŠ›ã€‚</p>
            <p>è¯¥è®¾å¤‡é‡‡ç”¨å…ˆè¿›çš„å½©è‰²ç”µå­å¢¨æ°´æŠ€æœ¯ï¼Œèƒ½å¤Ÿæ˜¾ç¤ºä¸°å¯Œçš„è‰²å½©ï¼ŒåŒæ—¶ä¿æŒä½åŠŸè€—å’Œçº¸è´¨èˆ¬çš„é˜…è¯»ä½“éªŒã€‚</p>
            <p>ä¸Šæ–¹çš„ 3D æ¨¡å‹å±•ç¤ºäº†è®¾å¤‡çš„ç²¾ç¡®å¤–è§‚å’Œè®¾è®¡ç»†èŠ‚ï¼Œæ‚¨å¯ä»¥é€šè¿‡é¼ æ ‡æ‹–æ‹½æ¥æ—‹è½¬æŸ¥çœ‹ä¸åŒè§’åº¦ã€‚</p>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, model;
        
        function createFallbackModel() {
            // Create a simple cube as fallback if STL doesn't load
            const geometry = new THREE.BoxGeometry(2, 1, 0.3);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0xd4a574,
                shininess: 30
            });
            const cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.receiveShadow = true;
            return cube;
        }
        
        function init() {
            const container = document.getElementById('model-viewer');
            const loadingMessage = container.querySelector('.loading-message');
            
            try {
                // Create scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf8f9fa);
                
                // Create camera
                camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.set(5, 5, 5);
                
                // Create renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Add renderer to container
                container.appendChild(renderer.domElement);
                
                // Add improved lighting for better detail visibility
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);
                
                // Main directional light
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene.add(directionalLight);
                
                // Add fill lights to reduce harsh shadows and show more detail
                const fillLight1 = new THREE.DirectionalLight(0xffffff, 0.3);
                fillLight1.position.set(-5, 5, -5);
                scene.add(fillLight1);
                
                const fillLight2 = new THREE.DirectionalLight(0xffffff, 0.2);
                fillLight2.position.set(0, -5, 5);
                scene.add(fillLight2);
                
                // Add grid for reference
                const gridHelper = new THREE.GridHelper(10, 10, 0xcccccc, 0xdddddd);
                gridHelper.position.y = -2;
                scene.add(gridHelper);
                
                // Add controls
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.enableZoom = true;
                controls.enablePan = false;
                controls.minDistance = 2;
                controls.maxDistance = 20;
                
                // Try to load STL model, fallback to cube if fails
                const loader = new STLLoader();
                
                // First try with the current filename
                loader.load(
                    'papercolor-00-01.stl',
                    function(geometry) {
                        loadSTLModel(geometry, loadingMessage);
                    },
                    function(progress) {
                        if (progress.lengthComputable) {
                            const percentComplete = (progress.loaded / progress.total * 100);
                            loadingMessage.textContent = `æ­£åœ¨åŠ è½½ 3D æ¨¡å‹... ${Math.round(percentComplete)}%`;
                        }
                    },
                    function(error) {
                        console.log('First STL load attempt failed, trying fallback cube...');
                        loadFallbackModel(loadingMessage);
                    }
                );
                
                // Add double-click to reset view
                renderer.domElement.addEventListener('dblclick', function() {
                    controls.reset();
                    camera.position.set(5, 5, 5);
                    if (model) {
                        camera.lookAt(model.position);
                    }
                });
                
                // Handle window resize
                window.addEventListener('resize', onWindowResize);
                
                animate();
                
            } catch (error) {
                console.error('Error initializing 3D viewer:', error);
                loadingMessage.textContent = '3D æŸ¥çœ‹å™¨åˆå§‹åŒ–å¤±è´¥';
            }
        }
        
        function loadSTLModel(geometry, loadingMessage) {
            try {
                // Log geometry info for debugging
                console.log('Geometry vertices:', geometry.attributes.position.count);
                console.log('Geometry has normals:', !!geometry.attributes.normal);
                
                // Ensure the geometry has normals for proper lighting
                if (!geometry.attributes.normal) {
                    geometry.computeVertexNormals();
                }
                
                // Create a more detailed material with better lighting
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0xd4a574,
                    roughness: 0.3,
                    metalness: 0.1,
                    side: THREE.DoubleSide,  // Show both sides
                    flatShading: false
                });
                
                // Create mesh
                model = new THREE.Mesh(geometry, material);
                model.castShadow = true;
                model.receiveShadow = true;
                
                // Center the model
                geometry.computeBoundingBox();
                const box = geometry.boundingBox;
                const center = new THREE.Vector3();
                box.getCenter(center);
                model.position.sub(center);
                
                // Scale the model to fit nicely in view
                const size = new THREE.Vector3();
                box.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 4 / maxDim;  // Slightly larger scale
                model.scale.setScalar(scale);
                
                // Position model slightly above ground
                model.position.y = 0.5;
                
                scene.add(model);
                
                // Log final model info
                console.log('Model bounding box size:', size);
                console.log('Model scale applied:', scale);
                console.log('Model final position:', model.position);
                
                // Hide loading message
                loadingMessage.textContent = 'STL æ¨¡å‹åŠ è½½æˆåŠŸï¼æ‹–æ‹½æ—‹è½¬ï¼Œæ»šè½®ç¼©æ”¾';
                setTimeout(() => {
                    loadingMessage.style.display = 'none';
                }, 2000);
                
                // Adjust camera to look at the model better
                camera.position.set(6, 4, 6);
                camera.lookAt(model.position);
                controls.target.copy(model.position);
                controls.update();
                
            } catch (error) {
                console.error('Error processing STL geometry:', error);
                loadFallbackModel(loadingMessage);
            }
        }
        
        function loadFallbackModel(loadingMessage) {
            // Create a simple device-like shape as fallback
            model = createFallbackModel();
            scene.add(model);
            
            loadingMessage.textContent = 'æ˜¾ç¤ºé¢„è§ˆæ¨¡å‹ - æ‹–æ‹½æ—‹è½¬ï¼Œæ»šè½®ç¼©æ”¾';
            setTimeout(() => {
                loadingMessage.style.display = 'none';
            }, 2000);
            
            console.log('Fallback model loaded');
        }
        
        function onWindowResize() {
            if (!camera || !renderer) return;
            const container = document.getElementById('model-viewer');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        function animate() {
            if (!renderer || !scene || !camera) return;
            requestAnimationFrame(animate);
            if (controls) controls.update();
            renderer.render(scene, camera);
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>